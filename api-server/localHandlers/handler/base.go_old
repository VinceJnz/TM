package handler

import (
	"database/sql"
	"encoding/json"
	"net/http"

	"github.com/jmoiron/sqlx"
)

// BaseRecord is an interface that defines methods common to all records
type BaseRecord interface {
	GetID() int
	SetID(id int)
}

// BaseHandler provides common functionality for CRUD operations
//
//	type BaseHandler[T BaseRecord] struct {
//		db     *sqlx.DB
//		table  string
//		fields string
//	}
type BaseHandler struct {
	db     *sqlx.DB
	table  string
	fields string
}

// NewBaseHandler creates a new BaseHandler
func NewBaseHandler[T any](db *sqlx.DB, table string, fields string) *BaseHandler {
	return &BaseHandler{db: db, table: table, fields: fields}
}

// GetID retrieves the record ID from the table
//func (h *BaseHandler) GetID() int {
//	return 0
//}

// SetID sets the record ID in the structure
//func (h *BaseHandler) SetID(id int) {
//}

// GetAll retrieves all records from the table
func (h *BaseHandler) GetAll(w http.ResponseWriter, r *http.Request, scanFunc func(*sql.Rows) (BaseRecord, error)) {
	rows, err := h.db.Query("SELECT " + h.fields + " FROM " + h.table)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var results []BaseRecord
	for rows.Next() {
		record, err := scanFunc(rows)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		results = append(results, record)
	}

	if err := rows.Err(); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(results)
}

// Get retrieves a single record by ID
func (h *BaseHandler) Get(w http.ResponseWriter, r *http.Request, id int, scanFunc func(*sql.Row) (BaseRecord, error)) {
	var record BaseRecord
	err := h.db.QueryRow("SELECT "+h.fields+" FROM "+h.table+" WHERE id = $1", id).Scan(scanFunc)
	if err == sql.ErrNoRows {
		http.Error(w, "Record not found", http.StatusNotFound)
		return
	} else if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(record)
}

// Create inserts a new record
func (h *BaseHandler) Create(w http.ResponseWriter, r *http.Request, insertFunc func(*BaseRecord) (int, error), record BaseRecord) {
	if err := json.NewDecoder(r.Body).Decode(record); err != nil {
		http.Error(w, "Invalid request payload", http.StatusBadRequest)
		return
	}

	id, err := insertFunc(&record)
	//_, err := insertFunc(record)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	//record.ID = id
	record.SetID(id)
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(record)
}

// Update updates an existing record
func (h *BaseHandler) Update(w http.ResponseWriter, r *http.Request, id int, updateFunc func(*BaseRecord) error, record BaseRecord) {
	if err := json.NewDecoder(r.Body).Decode(record); err != nil {
		http.Error(w, "Invalid request payload", http.StatusBadRequest)
		return
	}

	//record.ID = id
	record.SetID(id)
	if err := updateFunc(&record); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(record)
}

// Delete removes a record
func (h *BaseHandler) Delete(w http.ResponseWriter, r *http.Request, id int) {
	_, err := h.db.Exec("DELETE FROM "+h.table+" WHERE id = $1", id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}
