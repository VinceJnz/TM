package models

import (
	"encoding/json"
	"time"

	"github.com/go-webauthn/webauthn/webauthn"
)

//var W webauthn.WebAuthn
//var C webauthn.Credential

type WebAuthnCredential struct {
	ID              []byte    `db:"id"`
	PublicKey       []byte    `db:"public_key"`
	AttestationType string    `db:"attestation_type"`
	Transport       []byte    `db:"transport"`     // JSON-encoded
	Flags           []byte    `db:"flags"`         // JSON-encoded
	Authenticator   []byte    `db:"authenticator"` // JSON-encoded
	UserID          string    `db:"user_id"`
	CreatedAt       time.Time `db:"created_at"`
	UpdatedAt       time.Time `db:"updated_at"`
}

// Convert webauthn.Credential to DB format
func (c *WebAuthnCredential) FromWebAuthnCredential(cred webauthn.Credential, userID string) error {
	c.ID = cred.ID
	c.PublicKey = cred.PublicKey
	c.AttestationType = cred.AttestationType
	c.UserID = userID

	// JSON encode complex fields
	transportJSON, err := json.Marshal(cred.Transport)
	if err != nil {
		return err
	}
	c.Transport = transportJSON

	flagsJSON, err := json.Marshal(cred.Flags)
	if err != nil {
		return err
	}
	c.Flags = flagsJSON

	authenticatorJSON, err := json.Marshal(cred.Authenticator)
	if err != nil {
		return err
	}
	c.Authenticator = authenticatorJSON

	return nil
}

// Convert DB format back to webauthn.Credential
func (c *WebAuthnCredential) ToWebAuthnCredential() (webauthn.Credential, error) {
	var cred webauthn.Credential

	cred.ID = c.ID
	cred.PublicKey = c.PublicKey
	cred.AttestationType = c.AttestationType

	// JSON decode complex fields
	if err := json.Unmarshal(c.Transport, &cred.Transport); err != nil {
		return cred, err
	}

	if err := json.Unmarshal(c.Flags, &cred.Flags); err != nil {
		return cred, err
	}

	if err := json.Unmarshal(c.Authenticator, &cred.Authenticator); err != nil {
		return cred, err
	}

	return cred, nil
}

type WebAuthnCredential2 struct {
	ID              int      `json:"id" db:"id"`                             // This is the primary key, usually an auto-incremented integer
	UserID          int      `json:"user_id" db:"user_id"`                   // or string, depending on your user model. This is the foreign key to the user table
	CredentialID    string   `json:"credential_id" db:"credential_id"`       // base64-encoded string, unique identifier for the credential
	PublicKey       string   `json:"public_key" db:"public_key"`             // base64-encoded or PEM
	Handle          string   `json:"handle" db:"handle"`                     // user handle (WebAuthnHandle), Initially generated by the server during registration. User handle is compared to the user ID provided by the client during login.
	AttestationType string   `json:"attestation_type" db:"attestation_type"` // The attestation format used (if any) by the authenticator when creating the credential.
	Transport       []string `json:"transport" db:"transport"`               // The transports used by the authenticator to communicate with the client. This is a JSON array of strings, e.g., ["usb", "nfc", "ble", "internal"]
	// Flags for the credential
	BackupEligible bool `json:"backup_eligible" db:"backup_eligible"` // Can be synced?
	BackupState    bool `json:"backup_state" db:"backup_state"`       // Is it currently synced?
	// The Authenticator information for a given certificate
	AAGUID       string `json:"aaguid" db:"aaguid"`               // base64-encoded or hex
	SignCount    uint32 `json:"sign_count" db:"sign_count"`       // The number of times this credential has been used to sign
	CloneWarning bool   `json:"clone_warning" db:"clone_warning"` // This is used to indicate if the credential is a clone of another credential. It is not stored in the database, but is used during the authentication or login process.
	// db time tracking fields
	Created  time.Time `json:"created" db:"created"`
	Modified time.Time `json:"modified" db:"modified"`
}
